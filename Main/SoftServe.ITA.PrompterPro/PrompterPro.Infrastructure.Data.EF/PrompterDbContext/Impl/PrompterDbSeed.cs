using SoftServe.ITA.PrompterPro.Domain.Models;
using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace SoftServe.ITA.PrompterPro.Infrastructure.Data.EF.PrompterDbContext.Impl
{
    class PrompterDbSeed : CreateDatabaseIfNotExists<PrompterDbContext>
    {
        protected override void Seed(PrompterDbContext context)
        {
            GetRoles().ForEach(c => context.Roles.Add(c));
            GetOptions().ForEach(c => context.Options.Add(c));
            context.SaveChanges();
            GetUsers().ForEach(c => context.Users.Add(c));
            context.SaveChanges();
            GetScripts().ForEach(c => context.Scripts.Add(c));
            context.SaveChanges();
            GetSections().ForEach(c => context.Sections.Add(c));
            GetReaders().ForEach(c => context.Readers.Add(c));
            context.SaveChanges();
            GetPreferences().ForEach(c => context.Preferences.Add(c));

            context.SaveChanges();

            base.Seed(context);
        }

        private static List<Role> GetRoles()
        {
            return new List<Role>()
            {
                new Role { Name = "Admin" },
                new Role { Name = "Operator" },
                new Role { Name = "Prompter" }
            };
        }

        private static List<User> GetUsers()
        {
            return new List<User>
            {
                new User { Login = "Admin", Password = "e3afed0047b08059d0fada10f400c1e5", RoleId = 1, Disabled = false },
                new User { Login = "Operator", Password = "e1b3ec89ead7f83a9245ed5c9cacfdbf", RoleId = 2, Disabled = false },
                new User { Login = "Prompter", Password = "ef3318023090fa958a484c126ba577f2", RoleId = 3, Disabled = false , PrompterStatus= "On"}
            };
        }

        private static List<Options> GetOptions()
        {
            return new List<Options>
            {
                new Options { FontSize = 10, ReadingSpeed = 10, AnnouncerName = "Default" }
            };            
        }

        private static List<Script> GetScripts()
        {
            return new List<Script>
            {
                new Script { Title = "Module 8 - Regular Expressions", OperatorId = 2, OptionsId = 1, 
                    CreatedDate = new DateTime(2015, 3, 24, 22, 29, 32), 
                    LastEditedDate = new DateTime(2015, 3, 24, 22, 29, 32) }
            };
        }

        private static List<Section> GetSections()
        {
            return new List<Section>
            {
                new Section { Text = "Доброго дня, представляємо вашій увазі модуль 8 – регулярні вирази.", 
                    Order = 0, ScriptId = 1 },
                new Section
                {
                    Text = "У цьому модулі ми розглянемо наступні питання: спочатку познайомимось з тим, що являють собою регулярні вирази, далі розглянемо, як можна створювати і виконувати регулярні вирази у JavaScript; потім ми перейдемо до розгляду, яким саме чином слід конструювати регулярні вирази. Цей розділ розбитий на дві частини: у першій ми розглянемо основи, такі як повне співпадання символів, набори символів та основі спеціальні символи; у другій ми розглянемо дещо складніші питання, такі як квонтифікатори, управління жадібною чи нежадібною поведінкою регулярних виразів, а також групи захоплення та логічні оператори. Закінчимо розгляд модуля посиланнями на корисні ресурси.",
                    Order = 1,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "Отже, перейдемо до знайомства з регулярними виразами",
                    Order = 2,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "Регулярний вираз – це послідовність спеціальних символів, що формують шаблон, за яким здійснюється пошук.Концепція регулярних виразів була створена у 1950-х роках американським математиком Стівеном Кліном, хто формалізував опис мови регулярних виразів.Зараз регулярні вирази активно використовуються для перевірки чи екстракції потрібних даних та багато більше",
                    Order = 3,
                    ScriptId = 1
                },
                new Section
                {
                    Text = @"Рядок з регулярним виразом містить дві категорії символів: звичайні, які прямо зіставляються з символами цільового рядку, а також метасимволи – спеціальні символи, які мають спеціальне значення.У наведеному на слайді регулярному виразі символи зеленого кольору є звичайними символами, в той час як символи червоного кольору є метасимволами, що мають спеціальне значення.Наведений у якості прикладу регулярний вираз дозволяє зіставити слово 'center' або 'centre', написане у американському чи британському синтаксису.",
                    Order = 4,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "Перейдемо до створення та виконання регулярних виразів у JavaScript",
                    Order = 5,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "Мова JavaScript має спеціальний об'єкт регулярних виразів RexExp, для якого існує два варіанти створення екземплярів.У першому варіанті об'єкт створюється звичайним для JavaScript чином із використанням ключового слова 'new' та зазначенням функції-конструктора RegExp. У цьому випадку сам вираз передається у якості її параметра у вигляді рядку.Другий варіант дещо простіший за синтаксисом, у ньому регулярний вираз записується між двома слешами і рядок для його представлення не використовується.Обидва варіанти приводять до створення об'єкту одного у того ж типу, однак результат не завжди буде однаковий. Справа в тому, що символ зворотнього слеша трактується як службовий як у рядках, так і у регулярних виразах. А це означає, що у випадку запису регулярного виразу у рядку, спочатку зворотні слеші розглядатимуться як службові символи рядку, і для коректності регулярного виразу їх слід екранувати. Саме з цієї причини рекомендується не записувати регулярний вираз до рядку і використовувати другий варіант створення екземплярів регулярних виразів.",
                    Order = 6,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "Під час створення регулярних виразів можна опціонально використовувати прапорці, як окремо, так і довільній комбінації один з одним.Прапорець 'g' означає глобальний пошук, буде розглядатися нами далі.Прапорець 'i' використовується для позначення нечуттєвого до реєстру пошуку.Прапорець 'm' означає багаторядковий пошук.Прапорець 'y' дає можливість почати пошук з поточної позиції рядку.Для використання прапорців використовуйте синтаксис, наведений на слайді. Він відрізняється в залежності від того, яким саме чином створюється регулярний вираз.Зверніть увагу, що прапорці є інтегральною частиною регулярного виразу, їх неможна додати чи видалити після його створення.",
                    Order = 7,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "Для перевірки того, чи виконується або 'співпадає' регулярний вираз із тестовим рядком, слід використати метод test() об'єкту RegExp. Цей метод отримує рядок у вигляді параметру та повертає true у випадку співпадання, чи false – у противному випадку.У наведеному на слайді прикладі створюється рядок 'Hello' та регулярний вираз, що складається із однієї літери 'o'. Далі цей регулярний вираз перевіряється на співпадання із рядком, і, оскільки літера 'о' у ньому зустрічається, то повертає true.",
                    Order = 8,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "Для того, щоб визначити позицію символа рядку, з якого починається співпадання з регулярним виразом, використовується метод search() об'єкта String. Якщо метод знаходить співпадання, то повертає індекс першого символу, інакше – повертає -1.У наведеному на слайді прикладі здійснюється пошук символа 'о' у рядку. Як і у попередньому слайді створюється рядок 'Hello' та регулярний вираз, що складається із однієї літери 'o'.  При виконанні методу search() змінна result отримує значення 4, що відповідає п'ятому символу слова 'Hello'.",
                    Order = 9,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "Для того, щоб витягнути всі співпадання регулярного виразу із рядку слід використовувати метод match() об'єкту String, який отримує регулярний вираз як параметр та повертає масив з усіма співпаданнями, чи null, якщо співпадань немає. Слід звернути увагу, що регулярний вираз повинен мати прапорець 'g', у противному випадку метод буде працювати аналогічно методу exec() об'єкту RegExp, який потребує використання циклу для того, щоб отримати всі співпадання.У наведеному на слайді прикладі ми створюємо змінну str з рядком 'Hello World!' та регулярний вираз з однієї літери 'о' та прапорцем 'g', а потім виконуємо метод str.match() з параметром у вигляді нашого регулярного виразу. Результатом його виконання буде масив, що складається із двох літер 'о', знайдених у рядку.",
                    Order = 10,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "HTML5 підтримує спеціальний атрибут pattern для елемента input форми. Цей атрибут визначає регулярний вираз, який перевіряє введені користувачем дані і підтримується такими типами input як text, search, url, tel, email та password. За допомогою атрибута title можна вивести користувачу опис формату даних у якості підказки. Браузер не дозволяє відправити дані форми, якщо введені в input дані не відповідають формату pattern.На слайді наведено приклад форми, яка перевіряє на коректність автомобільний номер, що складається з двох великих латинських літер, далі чотирьох цифр та знову двох великих латинських літер.Зліва показано реакцію браузера у випадку введення невірних даних.",
                    Order = 11,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "Далі розглянемо, яким чином створюються регулярні вирази",
                    Order = 12,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "Для того, щоб перевірити на точну відповідність послідовності символів, ці символи, за умови, що серед них відсутні метасимволи, записуються у регулярному виразі 'як є'.Наприклад, регулярний вираз /pattern/ буде шукатися у рядку незалежно від місця його розташування.Для того, щоб явно задати, щоб пошук здійснювався лише на початку рядку, слід використовувати метасимвол каретки '^'. Для пошуку лише на кінці рядку – метасимвол долара '$', як наведено на прикладах.",
                    Order = 13,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "Використання метасимволу 'квадратні дужки' дозволяє задати набір символів. Співпадання будь-якого з символів із цього набору з символом із тестового рядку трактується як виконання умови виразу і регулярний вираз переходить до перевірки наступного символу за дужками.У наведеному прикладі регулярний вираз /[abc]/ буде співпадати із будь-яким рядком, що містить будь-який із символів 'a', 'b', 'c' у будь-якому місті тестового рядку.",
                    Order = 14,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "Вже знайомий нам символ каретки '^', що означає необхідність перевірки виразу з початку тестового рядку, у випадку розміщення на першому місці за квадратною дужкою змінює своє значення, і у такому випадку означає 'негативний набір символів', тобто такий набір, який має бути відустній на певному місці для успішного співпадання регулярного виразу ",
                    Order = 15,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "Символ зворотній слеш '\', розміщений перед звичайним символом, використовується для позначення того, що цей символ слід трактувати як спеціальний. У випадку, якщо зворотній слеш розміщується перед спеціальним символом, то він, навпаки, трактується як звичайний. Оскільки сам по собі зворотній слеш є спеціальним символом, то для його використання у якості звичайного символу його слід 'екранувати', тобто писати двічі.Нагадаємо, що зворотній слеш також разглядається у якості спеціального символу у рядках, а тому при створенні регулярного виразу через функцію-конструктор і запису регулярного виразу у рядку його також слід екранувати.",
                    Order = 16,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "У регулярних виразах ми можемо не лише перераховувати індивідуальні символи, а й їх діапазони, зазначаючи початковий та кінцевий символи через дефіс.Для деяких часто вживаних діапазонів існують спеціальні символи: маленьке 'w' означає буквенно-цифрові символи, куди входять латинські літери малого та великого реєстру, цифри, а також знак підкреслення;велике 'W' означає негативний набір символів до попереднього;маленьке 'd' означає цифри, а велике – відповідно, зворотній набір символів.",
                    Order = 17,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "Символ 'крапка' використовується для позначення будь-якого одиночного символу за виключенням символу початку рядку.У наведеному прикладі перед маленькою літерою 'n' може бути будь-який символ, однак 'n' не може стояти на початку рядку.",
                    Order = 18,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "Перейдемо до другої частини розгляду питань з конструювання регулярних виразів, де ми познайомимося з квонтифікаторами, розглянемо жадібну і нежадібну поведінку регулярних виразів, групи захоплення та логічні оператори",
                    Order = 19,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "Отже, що являє собою квонтифікатор? Це вказівка для інтерпретатору регулярного виразу, що окремий символ чи група має зустрічатися певну кількість разів. Для позначення квонтифікатора у регулярних виразах використовуються фігурні дужки, у яких зазначається точна кількість, чи мінімальна і максимальна кількість повторювань. Також існують спеціальні символи для позначення квонтифікаторів, зокрема '*', '+' та '?'. Їх ми розглянемо на наступних слайдах.Звернемо увагу на таку важливу особливість: за замовчуванням регулярні вирази розглядають квонтифікатори у 'жадібному' режимі, тобто у позначений квонтифікатором діапазон включається максимально можлива кількість символів, що відповідають умові виразу. Якщо ми хочемо навпаки включати мінімальну кількість символів, то ми маємо додавати знак питання за квонтифікатором, про що ми будемо говорити далі.",
                    Order = 20,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "Квонтифікатор 'зірочка' відповідає 0 чи довільній кількості символів. Еквівалентний до запису, де у фігурних дужках ми зазначаємо першим символом '0', а другий – не вказуємо.У наведеному прикладі квонтифікатор стосується символа 'о', який іде після 'b'. Таким чином, вираз буде співпадати у тому випадку, якщо після 'b' йде хоча б один символ 'о', чи, навіть, якщо немає жодного.",
                    Order = 21,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "Квонтифікатор 'плюс' відповідає одному чи довільній кількості символів. Еквівалентний до запису, де у фігурних дужках ми зазначаємо першим символом '1', а другий – не вказуємо.У наведеному прикладі квонтифікатор стосується символа 'о', який іде після 'b'. Таким чином, вираз буде співпадати у тому випадку, якщо після 'b' обов'язково йде хоча б один символ 'о'.",
                    Order = 22,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "Квонтифікатор 'знак питання' відповідає нулю чи одному символу. Еквівалентний до запису, де у фігурних дужках ми зазначаємо першим символом '0', а другий '1'.У наведеному прикладі квонтифікатор зустрічається двічі після двох символів 'e', тобто їх наявність не є обов'язковою, обов'язково має бути лише літера 'l'. Якщо ж знак питання зустрічається після квонтифікатора, то він переводить його у 'нежадібний' режим і примушує захоплювати мінімальну можливу кількість символів. Наприклад, використання виразу 'зворотній слеш, маленька літера d та квонтифікатор плюс' до виразу, що складається з символів '123abc' співпадає з фрагментом '123', однак додавання знаку питання до виразу призведе до результату, що співпадання скоротиться до '1'.",
                    Order = 23,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "Круглі дужки використовуються для позначення 'групи захоплення', що фактично означає вкладений під-вираз всередині регулярного виразу.Дуже часто групи захоплення використовуються з логічним оператором 'чи', який позначається за допомогою символу вертикальної риски.У наведеному прикладі ми створюємо рядок 'One man but many men' та регулярний вираз, який за допомогою вкладеної групи захоплення дозволяє виявити слова 'man' та 'men'. Далі ми за допомогою методу match() об'єкту String отримуємо масив, який наповнений витягнутими з рядку словами.",
                    Order = 24,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "Перейдемо до корисних посилань",
                    Order = 25,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "По-перше, рекомендуємо сайт RegEx101, який являє собою наглядний конструктор регулярних виразів.По-друге, на сайті Mozilla Developer Network знаходиться дуже детальний посібник з регулярних виразів.По-третє, сайт RexEgg містить багато детальних пояснень і прикладів з конструювання регулярних виразів.",
                    Order = 26,
                    ScriptId = 1
                },
                new Section
                {
                    Text = "Дякуємо за перегляд!",
                    Order = 27,
                    ScriptId = 1
                }
            };
        }

        private static List<Reader> GetReaders()
        {
            return new List<Reader>
            {
                new Reader { FirstName = "Леся", MiddleName = "Миронівна", LastName = "Клакович", LastScriptId = 1 }
            };
        }

        private static List<Preference> GetPreferences()
        {
            return new List<Preference>
            {
                new Preference { ReadingSpeed = 8, FontSize=70, ScreenHeight=422, ScreenWidth=1140,
                    ReaderId = 1, ScriptId = 1, LastSectionId = 8 }
            };
        }
    }
}
